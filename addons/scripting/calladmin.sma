/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <discord>


#pragma compress 1


#define PLUGIN "Call Admin ( Discord )"
#define VERSION "3.3"
#define AUTHOR "NIGHT HOWLER"

#define MAX_STR_NUM_LEN 64

#define FLAG_CALL_ADMIN		ADMIN_LEVEL_A


#define TASK_ANNOUCE 20202020

static const webhook[] = "calladmin";

// edit ur admin role id here
//static const admin_discord_role_id [] = "861571239277625365";

enum _:calladmin_reports { MESSAGEINDEX, MESSAGEID[32], DISPATCHER_AUTHID[MAX_AUTHID_LENGTH], DISPATCHER_NAME[MAX_NAME_LENGTH], 
	SUSPECT_AUTHID[MAX_AUTHID_LENGTH], SUSPECT_NAME[MAX_AUTHID_LENGTH], REASONS[64], DATETIME[32] }
new Array:reports;

enum _:resonsInfo { REASON[32] }
new Array:customReasons;

new bool:g_iCreatingReason[MAX_PLAYERS + 1];
new g_iReason[MAX_PLAYERS + 1][64];

new reportingID[MAX_PLAYERS + 1];

new const commandCallAdminMenu[][] = { "say /calladmin", "say_team /calladmin", "say calladmin", "say_team calladmin" };

new const reportStatus[][] = 
{
	"Report Accepted",
	"Fake Report",
	"Report Declined",
	"Player Warned",
	"Player Banned",
	"Reporter Warned",
	"Reporter Banned",
	"Insufficient Evidence",
	"Player Left",
};

new const reportStatusLink[][] = 
{
	"https://media.discordapp.net/attachments/703164131926343811/914503043532337152/emb1.png",		// Report Accepted
	"https://media.discordapp.net/attachments/703164131926343811/914503043712700426/emb2.png",		// Fake Report
	"https://media.discordapp.net/attachments/703164131926343811/914503044425723944/emb3.png",		// Report Declined
	"https://media.discordapp.net/attachments/703164131926343811/914503043951783936/emb4.png",		// Player Warned
	"https://media.discordapp.net/attachments/703164131926343811/914503044723515472/emb5.png",		// Player Banned
	"https://media.discordapp.net/attachments/703164131926343811/914503044937433170/emb6.png",		// Reporter Warned
	"https://media.discordapp.net/attachments/703164131926343811/914503045134553119/emb7.png",		// Reporter Banned
	"https://media.discordapp.net/attachments/703164131926343811/914503045495267328/emb8.png",		// Insufficient Evidence
	"https://media.discordapp.net/attachments/703164131926343811/914503045948272710/emb9.png",		// Player Left
};

enum _:CallData
{
	AUTHID[ 35 ],
	TIME_DISPATCHED
};

new Array:g_aCallData;

new pcvar_cooldown, pcvar_serveradminid, pcvar_serverip, pcvar_announce, pcvar_warnings;

new msgid;


#define TASK_MSG_CHECK 209


public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	for (new i; i < sizeof commandCallAdminMenu; i++) register_clcmd(commandCallAdminMenu[i], "CmdCallAdmin");
	
	//Round start event.
	register_event("HLTV", "new_round", "a", "1=0", "2=0");
	
	register_clcmd("Reason?", "clcmd_reason")
	
	register_clcmd("say /reports", "showcalladminreports", FLAG_CALL_ADMIN);
	register_clcmd("say_team /reports", "showcalladminreports", FLAG_CALL_ADMIN);
	
	
	g_aCallData        = ArrayCreate( CallData );
	reports 	= ArrayCreate( calladmin_reports );
	
	pcvar_cooldown = register_cvar("calladmin_cooldown_min", "5");
	
	
	pcvar_serveradminid = register_cvar("calladmin_server_admin_roleid", "0");
	pcvar_serverip = register_cvar("calladmin_server_ip", "0");
	pcvar_announce = register_cvar("calladmin_announce", "1");
	pcvar_warnings = register_cvar("calladmin_warnings", "1");
	
	
	register_dictionary( "calladmin_discord.txt" );
	
	
}


public showcalladminreports(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
	{
		return PLUGIN_HANDLED;
	}
	
	/* --| Menu stuff */
	new szText[ 555 char ];
	//formatex( szText, charsmax( szText ), "\yReports Pending \w[\rReporters\w]");
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_MENU_TITLE" );
	new menu = menu_create( szText, "showcalladminreports_handler" );
	
	if(ArraySize(reports))
	{
		for (new i = 0; i < ArraySize(reports); i++) 
		{
			static report[calladmin_reports];
			ArrayGetArray(reports, i, report);
			
			new reportername[MAX_NAME_LENGTH+1];
			
			new data[2];
			data[0] = report[MESSAGEINDEX];
			
			//formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTING" );
			formatex(reportername, charsmax(reportername), "%s", report[SUSPECT_NAME]);
			
			menu_additem(menu, reportername, data);
			
			
		}
		
		menu_setprop( menu, MPROP_EXIT, MEXIT_ALL );
		/* --| Show the menu, with current page 0 */
		menu_display( id, menu, 0 );
		
		return PLUGIN_HANDLED;
	}
	else
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_NONE" );
		client_print_color(id, id, szText);
		//client_print_color(id, id, "^1[^4CALL ADMIN^1] No reports pending.");
		
	}
	return PLUGIN_CONTINUE;
	
}

public showcalladminreports_handler(id, menu, item)
{
	
	/* --| If key is 0, let's close the menu */
	if( item == MENU_EXIT )
	{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	
	/* --| Getting the menu information */
	new data[ 6 ], iName[ 64 ], access, callback;
	menu_item_getinfo( menu, item, access, data, charsmax( data ), iName, charsmax( iName ), callback );

	/* --| Get menu keys */
	new key = data[0];
	
	show_menu_ch_msgid(id, key);
	return PLUGIN_HANDLED;
}
	
public show_menu_ch_msgid(id, msgid)
{
	new szText[555];
	if(ArraySize(reports))
	{
		for (new i = 0; i < ArraySize(reports); i++) 
		{
			static callreport[calladmin_reports];
			ArrayGetArray(reports, i, callreport);
			
			
			if(callreport[MESSAGEINDEX] == msgid)
			{
				/* --| Menu stuff */
				new szText[ 555 char ];
				//formatex( szText, charsmax( szText ), "\rCall Admin Reports\n\w[\rReporter:\w %s]^n[\rReportng:\w %s]", callreport[DISPATCHER_NAME]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_MENU_2", callreport[DISPATCHER_NAME], callreport[SUSPECT_NAME] );
				
				new menu = menu_create( szText, "show_menu_ch_msgid_handler" );
				
				new data[2];
				data[0] = msgid;
				data[1] = 1;
				menu_additem(menu, "View Report", data)
				menu_addblank2(menu);
				menu_addblank2(menu);
				menu_addblank2(menu);
				data[1] = 2;
				menu_additem(menu, "Close Report", data)
				
				menu_setprop( menu, MPROP_EXIT, MEXIT_ALL );
				/* --| Show the menu, with current page 0 */
				menu_display( id, menu, 0 );	
				
			}
		}
	}
	else
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_MISSING" );
		client_print_color(id, id, szText);
		//client_print_color(id, id, "^1[^4CALL ADMIN^1] It seems report no longer exists.");
		return PLUGIN_HANDLED;
		
	}
	return PLUGIN_CONTINUE;
	
}


public show_menu_ch_msgid_handler(id, menu, item)
{
	
	/* --| If key is 0, let's close the menu */
	if( item == MENU_EXIT )
	{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	
	/* --| Getting the menu information */
	new data[ 6 ], iName[ 64 ], access, callback;
	menu_item_getinfo( menu, item, access, data, charsmax( data ), iName, charsmax( iName ), callback );

	/* --| Get menu keys */
	new msgid = data[0];
	
	new key = data[1];
	
	switch( key )
	{
		case 1: 
		{
			show_report(id, msgid);
		}
		case 2:
		{
			close_report(id, msgid);
		}
	}
	
	return PLUGIN_HANDLED;
}

public show_report(id, msgid)
{
	new szText[555];
	if(ArraySize(reports))
	{
		for (new i = 0; i < ArraySize(reports); i++) 
		{
			static callreport[calladmin_reports];
			ArrayGetArray(reports, i, callreport);
			
			
			if(callreport[MESSAGEINDEX] == msgid)
			{
				/* --| Menu stuff */
				new szText[ 555 char ];
				//formatex( szText, charsmax( szText ), "\rCall Admin Reports^nReport Info:");
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_MENU_INFO" );
				
				
				new menu = menu_create( szText, "show_report_handler" );
				
				new data[3];
				data[0] = msgid;
				data[1] = 0;
				//formatex( szText, charsmax( szText ), "\yReporter:\w %s", callreport[DISPATCHER_NAME])
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_REPORTER", callreport[DISPATCHER_NAME] );
				menu_addtext2(menu, szText)//, data)
				//formatex( szText, charsmax( szText ), "\yReporter SteamID :\w %s", callreport[DISPATCHER_AUTHID]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_R_STEAMID", callreport[DISPATCHER_AUTHID] );
				menu_addtext2(menu, szText);
				
				//formatex( szText, charsmax( szText ), "\ySuspect:\w %s", callreport[SUSPECT_NAME]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_SUSPECT", callreport[SUSPECT_NAME] );
				menu_addtext2(menu, szText)//, data)
				//formatex( szText, charsmax( szText ), "\ySuspect SteamID :\w %s", callreport[SUSPECT_AUTHID]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_S_STEAMID", callreport[SUSPECT_AUTHID] );
				menu_addtext2(menu, szText);
				
				//formatex( szText, charsmax( szText ), "\yReason:\w %s", callreport[REASONS]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_REASON", callreport[REASONS] );
				menu_addtext2(menu, szText)//, data)
				
				menu_addblank2(menu);
				menu_addblank2(menu);
				data[1] = 1;
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_CLOSE" );
				//menu_additem(menu, "Close Report", data)
				menu_additem(menu, szText, data)
				menu_addblank2(menu);
				
				
				
				menu_setprop(menu, MPROP_PERPAGE, 0); 
				menu_setprop( menu, MPROP_EXIT, MEXIT_FORCE );
				/* --| Show the menu, with current page 0 */
				menu_display( id, menu, 0 );	
				
			}
		}
	}
	else
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_MISSING" );
		client_print_color(id, id, szText);
		//client_print_color(id, id, "^1[^4CALL ADMIN^1] It seems report no longer exists.");
		return PLUGIN_HANDLED;
		
	}
	return PLUGIN_CONTINUE;
	
}

public show_report_handler(id, menu, item)
{
	
	/* --| If key is 0, let's close the menu */
	if( item == MENU_EXIT )
	{
		menu_destroy( menu );
		//return PLUGIN_HANDLED;
	}
	
	
	/* --| Getting the menu information */
	new data[ 6 ], iName[ 64 ], access, callback;
	menu_item_getinfo( menu, item, access, data, charsmax( data ), iName, charsmax( iName ), callback );

	/* --| Get menu keys */
	new msgid = data[0];
	
	new key = data[1];
	
	if(key == 1)
	{
		close_report(id, msgid);
		
	}
	else menu_display(id, menu);
	
	return PLUGIN_CONTINUE;
}

public close_report(id, msgid)
{
	new szText[555];
	if(ArraySize(reports))
	{
		for (new i = 0; i < ArraySize(reports); i++) 
		{
			static callreport[calladmin_reports];
			ArrayGetArray(reports, i, callreport);
			
			
			if(callreport[MESSAGEINDEX] == msgid)
			{
				/* --| Menu stuff */
				new szText[ 555 char ];
				//formatex( szText, charsmax( szText ), "\yReport Status");
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_STATUS" );
				
				new menu = menu_create( szText, "close_report_handler" );
				
				new data[3];
				
				data[0] = msgid;
				data[1] = 0;
				data[2] = 0;
				
				for(new i; i < sizeof(reportStatus); i++)
				{
					data[1] = i+1;
					formatex( szText, charsmax( szText ), "%s", reportStatus[i]);
					menu_additem(menu, szText, data)
					
				}
				menu_setprop(menu, MPROP_PERPAGE, 0); 
				menu_setprop( menu, MPROP_EXIT, MEXIT_FORCE );
				/* --| Show the menu, with current page 0 */
				menu_display( id, menu, 0 );
				
			}
		}
	}
	else
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_MISSING" );
		client_print_color(id, id, szText);
		//client_print_color(id, id, "^1[^4CALL ADMIN^1] It seems report no longer exists.");
		return PLUGIN_HANDLED;
		
	}
	return PLUGIN_CONTINUE;		
				
}

public close_report_handler(id, menu, item)
{
	/* --| If key is 0, let's close the menu */
	if( item == MENU_EXIT )
	{
		menu_destroy( menu );
		//return PLUGIN_HANDLED;
	}
	
	
	/* --| Getting the menu information */
	new data[ 6 ], iName[ 64 ], access, callback;
	menu_item_getinfo( menu, item, access, data, charsmax( data ), iName, charsmax( iName ), callback );

	/* --| Get menu keys */
	new msgid = data[0];
	
	new key = data[1];
	
	if(key > 0 && key < 10)
	{
		MakeConfirmCloseMenu(id, msgid, key);
		
	}
}

public MakeConfirmCloseMenu(id, msgid, status)
{
	new szText[ 555 char ];
	if(ArraySize(reports))
	{
		for (new i = 0; i < ArraySize(reports); i++) 
		{
			static callreport[calladmin_reports];
			ArrayGetArray(reports, i, callreport);
			
			
			if(callreport[MESSAGEINDEX] == msgid)
			{
				/* --| Menu stuff */
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_CONFIRM_TITLE" );
				//formatex( szText, charsmax( szText ), "\rClose This Report?");
				
				new menu = menu_create( szText, "MakeConfirmCloseMenu_handler" );
				
				new data[3];
				
				data[0] = msgid;
				data[1] = 0;
				data[2] = status;
				new sts = status - 1;
				//formatex( szText, charsmax( szText ), "\yReporter:\w %s", callreport[DISPATCHER_NAME]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_REPORTER", callreport[DISPATCHER_NAME] );
				menu_addtext2(menu, szText)
				//formatex( szText, charsmax( szText ), "\yReporter SteamID :\w %s", callreport[DISPATCHER_AUTHID]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_R_STEAMID", callreport[DISPATCHER_AUTHID] );
				menu_addtext2(menu, szText);
				
				//formatex( szText, charsmax( szText ), "\ySuspect:\w %s", callreport[SUSPECT_NAME]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_SUSPECT", callreport[SUSPECT_NAME] );
				menu_addtext2(menu, szText)
				//formatex( szText, charsmax( szText ), "\ySuspect SteamID :\w %s", callreport[SUSPECT_AUTHID]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_S_STEAMID", callreport[SUSPECT_AUTHID] );
				menu_addtext2(menu, szText)
				
				//formatex( szText, charsmax( szText ), "\yReason:\w %s", callreport[REASONS]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_REASON", callreport[REASONS] );
				menu_addtext2(menu, szText)
				//formatex( szText, charsmax( szText ), "\yStatus:\w %s", reportStatus[sts]);
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_STATUS", reportStatus[sts] );
				menu_addtext2(menu, szText)
				
				
				menu_addblank2(menu);
				
				data[1] = 1;
				formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_REPORTS_INFO_CLOSE_YES" );
				menu_additem(menu, szText, data)
				//menu_additem(menu, "\rYes Close This Report", data)
				menu_addblank2(menu);
				
				
				menu_setprop(menu, MPROP_PERPAGE, 0); 
				menu_setprop( menu, MPROP_EXIT, MEXIT_FORCE );
				/* --| Show the menu, with current page 0 */
				menu_display( id, menu, 0 );
			}
		}
	}
	else
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_MISSING" );
		client_print_color(id, id, szText);
		//client_print_color(id, id, "^1[^4CALL ADMIN^1] It seems report no longer exists.");
		return PLUGIN_HANDLED;
		
	}
	return PLUGIN_CONTINUE;
	
}

public MakeConfirmCloseMenu_handler(id, menu, item)
{
	/* --| If key is 0, let's close the menu */
	if( item == MENU_EXIT )
	{
		menu_destroy( menu );
		//return PLUGIN_HANDLED;
	}
	
	
	/* --| Getting the menu information */
	new data[ 6 ], iName[ 64 ], access, callback;
	menu_item_getinfo( menu, item, access, data, charsmax( data ), iName, charsmax( iName ), callback );

	/* --| Get menu keys */
	new msgid = data[0];
	new key = data[1];
	new status = data[2] - 1;
	
	if(key)
	{
		EndReport(id, msgid, status);
		
		
	}	
}

public EndReport(id, msgid, status)
{
	new szText[555];
	if(ArraySize(reports))
	{
		for (new i = 0; i < ArraySize(reports); i++) 
		{
			static callreport[calladmin_reports];
			ArrayGetArray(reports, i, callreport);
			
			
			if(callreport[MESSAGEINDEX] == msgid)
			{
				// formating
				new ctime[64]
				get_time("%m/%d/%Y - %H:%M:%S", ctime, charsmax(ctime))
				new serverName[128];
				get_user_name(0, serverName, charsmax(serverName));
				new serverIP[128];
				get_pcvar_string(pcvar_serverip, serverIP, charsmax(serverIP));
				if(equal(serverIP, "0"))
				{
					
					get_user_ip(0, serverIP, charsmax(serverIP));
				}
				
				new map[32];
				get_mapname(map, charsmax(map));
				
				new freindcode[64], communityID[128], serverInfo[128];
				
				msgid = Discord_StartMessage();
				if (msgid)
				{
					// Send Message to Discord Here;
					new empty[] = "_ _";
					
					
					//Discord_SetStringParam(FOOTER_TEXT, "CallAdmin Version %s [ Author: %s ]", VERSION, AUTHOR);
					Discord_SetCellParam(COLOR, 0x73e405);
					
					// content part ( mention admin here and ur message)
					Discord_SetStringParam(CONTENT, "%s", reportStatus[status]);
					Discord_SetStringParam(EMBED_IMAGE, "%s", reportStatusLink[status]);
					
					// row 1, server name and ip
					formatex(serverInfo, charsmax(serverInfo), "[%s](http://ugc.gs/steam.php?addr=%s)", serverName, serverIP);
					
					
					
					Discord_AddField("Server Name",serverInfo, true);
					formatex(serverInfo, charsmax(serverInfo), "%s", serverIP);
					Discord_AddField("Server IP",serverInfo, true);
					Discord_AddField(empty, empty, true);
					
					// row 1, steam connect and map
					formatex(serverInfo, charsmax(serverInfo), "steam://connect/%s", serverIP);
					Discord_AddField("Steam Connect",serverInfo, true);
					Discord_AddField("Map",map, true);
					Discord_AddField(empty, empty, true);
			
					
					// row 3 , dispatcher name and authid
					Discord_AddField("Dispatcher Name",callreport[DISPATCHER_NAME], true);
			
					GetFriendID(callreport[DISPATCHER_AUTHID],freindcode,charsmax(freindcode))
					formatex(communityID, charsmax(communityID), "[%s](http://steamcommunity.com/profiles/%s)", callreport[DISPATCHER_AUTHID], freindcode);
					Discord_AddField("Dispatcher SteamID",communityID, true);
					Discord_AddField(empty, empty, true);
					
					
					
					// row 4 , suspect name and authid
					Discord_AddField("Suspect Name",callreport[SUSPECT_NAME], true);
					GetFriendID(callreport[SUSPECT_AUTHID],freindcode,charsmax(freindcode))
					formatex(communityID, charsmax(communityID), "[%s](http://steamcommunity.com/profiles/%s)", callreport[SUSPECT_AUTHID], freindcode);
					Discord_AddField("Suspect SteamID",communityID, true);
					Discord_AddField(empty, empty, true);
					
					
					// row 5, Reason and Date & Time of report
					Discord_AddField("Reason",callreport[REASONS], true);
					Discord_AddField("Date & Time",callreport[DATETIME], true);
					Discord_AddField(empty, empty, true);
					
					// row 6, Admin and Status
					new admin[MAX_NAME_LENGTH];
					
					get_user_name(id, admin, charsmax(admin));
					
					Discord_AddField("Admin",admin, true);
					Discord_AddField("Status",reportStatus[status], true);
					Discord_AddField(empty, empty, true);
					
					Discord_EditMessage(webhook, callreport[MESSAGEID]);
					
					new user = find_player("c", callreport[DISPATCHER_AUTHID]);
					
					ArrayDeleteItem(reports, i);
					formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_CLOSED_SUCCESFULLY" );
					client_print_color(id, id, szText);
					//client_print_color(id, id, "^1[^4CALL ADMIN^1] Report Successfully Closed.");
					
					if(user && is_user_connected(user))
					{
						formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_CLOSED_INFORM", admin, reportStatus[status] );
						client_print_color(user, id, szText);
						//client_print_color(user, id, "^1[^4CALL ADMIN^1] Your report has been closed by ^4Admin ^3%s^1.", admin);
						clear_cooldown(user);
					}
					
					
				}
			}
		}
	}
	else
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORTS_MISSING" );
		client_print_color(id, id, szText);
		//client_print_color(id, id, "^1[^4CALL ADMIN^1] It seems report no longer exists.");
		return PLUGIN_HANDLED;
		
	}
	return PLUGIN_HANDLED;
	
}

public new_round()
{
	set_task(20.0, "announce", TASK_ANNOUCE);

	
}

public announce()
{
	if(get_pcvar_num(pcvar_announce))
	{
		new szText[555];
		static iPlayers[32], iNum, id, i;
		get_players(iPlayers, iNum, "ch");
		
		for( i = 0; i < iNum; i++ )
		{
			id = iPlayers[i];
			
			formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_ANNOUNCE" );
			client_print_color(id, id, szText);
			//client_print_color(0, 0, "^1[^4CALL ADMIN^1] To report a user to our active admins from our discord server, write in chat ^4/calladmin^1 .")
		}
		
		if(task_exists(TASK_ANNOUCE))
			remove_task(TASK_ANNOUCE);
		
	}
	
	return PLUGIN_CONTINUE;
}

public get_user_call_time(id)
{
	new authid[32];
	get_user_authid(id, authid, charsmax(authid));
	for (new i = 0; i < ArraySize(g_aCallData); i++) 
	{
		static callAdminData[ CallData ];
		ArrayGetArray(g_aCallData, i, callAdminData);
		
		if(equal(callAdminData[AUTHID], authid))
		{
			return callAdminData[TIME_DISPATCHED];
		}
		
	}
	return 0;	
}

public clear_cooldown(id)
{
	
	new authid[32];
	get_user_authid(id, authid, charsmax(authid));
	for (new i = 0; i < ArraySize(g_aCallData); i++) 
	{
		static callAdminData[ CallData ];
		ArrayGetArray(g_aCallData, i, callAdminData);
		
		if(equal(callAdminData[AUTHID], authid))
		{
			ArrayDeleteItem(g_aCallData, i);
			return 1;
		}
		
	}
	return 0;
	
	
}

public CmdCallAdmin(id)
{
	if(is_user_bot(id) || is_user_hltv(id) )
		return PLUGIN_HANDLED;
	
	new timeOfCall = get_user_call_time(id)
	
	new cooldown_min = get_pcvar_num(pcvar_cooldown);
	
	new cooldown_sec = cooldown_min * 60;
	
	new current_time = get_systime();
	
	new time_over = timeOfCall + cooldown_sec;
	new szText[555];
	if(current_time >= time_over)
	{
		clear_cooldown(id);
		showCallAdminMenu(id)
	}
	else
	{
		new timestr[64];
		new timeleft = time_over - current_time;
		FormatTime(timeleft, timestr, sizeof timestr);
		
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_RECENTLY_MADE", timestr );
		client_print_color(id, print_team_default, szText);
		//client_print_color(id, print_team_default, "^1[^4Call Admin^1] You have recently maded a call admin request. You can make another request after ^3%s .", timestr);
		
	}
	return PLUGIN_HANDLED;
}

public showCallAdminMenu(id)
{
	g_iCreatingReason[id] = false;
	reportingID[id] = 0;
	
	new szText[555];
	new players[32], pnum, tempid;
	new szName[32], szUserId[32];
	get_players(players, pnum, "ch");
	
	if(pnum > 1 && get_pcvar_num(pcvar_warnings))
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_WARN_ONE" );
		client_print_color(id, print_team_default, szText);
		//client_print_color(id, print_team_default, "^1[^4Call Admin^1] ^3WARNING! ^4Fake Call Admin Request ^1can lead to ^3Punishment like gag/ban.");
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_WARN_TWO" );
		client_print_color(id, print_team_default, szText);
		//client_print_color(id, print_team_default, "^1[^4Call Admin^1] ^3WARNING! ^1Use Call Admin wisely and on your own resposibility.");
	}
	else
	{
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_NO_PLAYER" );
		client_print_color(id, print_team_default, szText);
		//return PLUGIN_HANDLED;
		//client_print_color(id, print_team_default, "^1[^4Call Admin^1] ^3No Player Detected.");
	}
	
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_MENU" );
	new menu = menu_create( szText, "call_admin_handler" );
	//new menu = menu_create( "\w Call Admin: \r[\yWhom you want to report\r]", "call_admin_handler" );

	for ( new i; i<pnum; i++ )
	{
		tempid = players[i];
		//if(tempid != id)
		//if(tempid)
		if(tempid)
		{
			get_user_name( tempid, szName, charsmax( szName ) );
			formatex( szUserId, charsmax( szUserId ), "%d", get_user_userid( tempid ) );
			menu_additem( menu, szName, szUserId, 0 );
		}
		
	}
	
	menu_display( id, menu, 0 );

	return PLUGIN_HANDLED;
}

public clcmd_reason(id)
{
	if(g_iCreatingReason[id])
	{
		
		new sReason[64]
		read_args(sReason, charsmax(sReason))
		remove_quotes(sReason)
		
		g_iCreatingReason[id] = false;
		
		new player = reportingID[id];
		new reasonindex = 99;
		
		formatex( g_iReason[id], charsmax(g_iReason[]), "%s", sReason);
		MakeConfirmMenu(id, player, reasonindex);
		
	}
	
	return PLUGIN_HANDLED;
	
}


public plugin_precache()
{
	
	customReasons = ArrayCreate(resonsInfo);
	
	
	new reasons[256];
	new configdir[200]
	get_configsdir(configdir,199)
	formatex(reasons, charsmax(reasons), "%s/calladmin/reasons.ini", configdir);
	
	new Len, Line[256], FileLine;
	FileLine = file_size(reasons, 1);
	for(new Num = 0; Num < FileLine; Num++)
	{
		new szReason[32], szDump[256]
		read_file(reasons, Num, Line, 255, Len);
		parse(Line, szReason, charsmax(szReason), szDump, charsmax(szDump));
		
		remove_quotes(szReason);
		remove_quotes(szDump);
		
		if(Line[0])
		{
			if(Line[0] == ';' || strlen(Line) < 3)
				continue;
			
			static reason[resonsInfo];
			
			formatex(reason[REASON], charsmax(reason[REASON]), szReason);
			
			ArrayPushArray(customReasons, reason);
		}
		
	}
}

public call_admin_handler( id, menu, item )
{
	new dispatcher[32];
	
	get_user_name(id,dispatcher,32);
	
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	new szData[6], szName[64];
	new _access, item_callback;
	menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	
	new userid = str_to_num( szData );
	new player = find_player( "k", userid ); 
	
	
	if ( player )
	{
		reportingID[id] = player;
		show_reasons(id, player);
	}

	menu_destroy( menu );
	return PLUGIN_HANDLED;
}

public show_reasons(id, player)
{
	/* --| Menu stuff */
	new szText[ 555 char ];
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_SELECT_REASON" );
	//formatex( szText, charsmax( szText ), "\ySelect Reason");
	
	new menu = menu_create( szText, "show_reasons_handler" );
	
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_CUSTOM_REASON" );
	//formatex( szText, charsmax( szText ), "\yCustom Reason");
	menu_additem(menu, szText, "cstm")
	
	for (new i = 0; i < ArraySize(customReasons); i++) 
	{
		static reasons[resonsInfo];
		ArrayGetArray(customReasons, i, reasons);
		
		new info[11];
		formatex( info, charsmax( info ), "%d?%d", player, i);
		formatex( szText, charsmax( szText ), "%s", reasons[REASON]);
		menu_additem(menu, szText, info)		
			
		
	}
	
	menu_setprop( menu, MPROP_EXIT, MEXIT_ALL );
	
	/* --| Show the menu, with current page 0 */
	menu_display( id, menu, 0 );
	
	return PLUGIN_HANDLED;
	
}


public show_reasons_handler(id, menu, item)
{
	
	new szText[ 555 char ];
	
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	new szData[6], szName[64];
	new _access, item_callback;
	menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );

	if(equal(szData, "cstm"))
	{
		g_iCreatingReason[id] = true;
		client_cmd(id, "messagemode Reason?")
		formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_SPECIFY_REASON" );
		client_print_color(id, print_team_default, szText);
		//client_print_color(id, print_team_default, "^1[^4Call Admin^1] Please specify the reason in breif. [Max 64 characters]");
		return PLUGIN_HANDLED;
	}
	else
	{
		
		new info_str[2][11]
		str_explode(szData, '?', info_str, 2, 10);
		
		new userid = str_to_num( info_str[0] );
		new reasonindex = str_to_num( info_str[1] );
		
		
		new player = userid;
		
		
		if ( is_user_connected( player ))
		{
			reportingID[id] = player;
			
			MakeConfirmMenu(id, player, reasonindex);
		}
	}
	
	menu_destroy( menu );
	return PLUGIN_HANDLED;
	
}

public MakeConfirmMenu(id, player, reasonindex)
{
	g_iCreatingReason[id] = false;
	
	new suspect[32], reason[64];
	get_user_name(player, suspect, charsmax(suspect));
	get_reason(id, reasonindex, reason, charsmax(reason));
	
	/* --| Menu stuff */
	new szText[ 555 char ];
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_CONFIRM_MENU", suspect, reason );
	//formatex( szText, charsmax( szText ), "\yCall Admin \r[\wConfirm Before Sending Report\r]^n^n\r>>\yReporting: \w%s^n\r>>\yReason: \w%s", suspect, reason);
	
	new menu = menu_create( szText, "MakeConfirmMenu_Handler" );
	
	new info_str[10];
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_EDIT_INFO" );
	//formatex( szText, charsmax( szText ), "\yEdit Info" );
	formatex( info_str, charsmax( info_str ), "1?%d", reasonindex );
	menu_additem(menu, szText, info_str);
	
	menu_addblank2(menu);
	menu_addblank2(menu);
	
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_YES" );
	//formatex( szText, charsmax( szText ), "\rYES", );
	formatex( info_str, charsmax( info_str ), "2?%d", reasonindex );
	menu_additem(menu, szText, info_str);
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_NO" );
	//formatex( szText, charsmax( szText ), "\rNO", );
	formatex( info_str, charsmax( info_str ), "3?%d", reasonindex );
	menu_additem(menu, szText, info_str);
	
	menu_addblank2(menu);
	menu_addblank2(menu);
	formatex( szText, charsmax( szText ), "%L", id, "CALLADMIN_CONFIRM_MENU_WARNING" );
	menu_addtext2(menu, szText);
	//menu_addtext2(menu, "\y[\rWarning\y]^n\yFake Call Admin Reports will result in \rPunishment\y.^nSo make call with responsibilities.");
	
	menu_setprop(menu, MPROP_PERPAGE, 0); 	
	menu_setprop(menu, MPROP_EXIT, MEXIT_NEVER);
	/* --| Show the menu, with current page 0 */
	menu_display( id, menu, 0 );
	
	return PLUGIN_HANDLED;
	
}

public MakeConfirmMenu_Handler( id, menu, item )
{
	new dispatcher[32];
	new szText[ 555 char ];
	
	get_user_name(id,dispatcher,32);
	
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	new szData[6], szName[64];
	new _access, item_callback;
	menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	
	new info_str[2][11]
	str_explode(szData, '?', info_str, 2, 10);
	
	new key = str_to_num( info_str[0] );
	//new userid = str_to_num( info_str[1] );
	new reasonindex = str_to_num( info_str[1] );
	
	new player = reportingID[id];
	
	switch( key )
	{
		case 1:
		{
			showCallAdminMenu(id);
			return PLUGIN_HANDLED;	
		}
		case 2:
		{
			new Reason[64];
			get_reason(id, reasonindex, Reason, charsmax(Reason));
			
			if(is_user_connected( player ))
			{
				
				SendReportToDiscord(id, player, Reason)
				return PLUGIN_HANDLED;	
			}
			else
			{
				formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_FAILED_TO_FIND_USER" );
				client_print_color(id, print_team_default, szText);
				//client_print_color(id, print_team_default, "^1[^4Call Admin^1] Sorry, Cant find the mentioned user. Please repeat the steps.");
				showCallAdminMenu(id);
				return PLUGIN_HANDLED;	
			}
		}
		case 3:
		{
			menu_destroy( menu );
			return PLUGIN_HANDLED;	
		}
		
		
	}
	return PLUGIN_HANDLED
}

public SendReportToDiscord(id, player, const Reason[])
{
	new dispatcher[32], disAuth[32];
	new suspect[32], susAuth[32];
	// formating
	new ctime[64]
	get_time("%m/%d/%Y - %H:%M:%S", ctime, charsmax(ctime))
	get_user_name(player, suspect, charsmax(suspect));
	get_user_name(id, dispatcher, charsmax(dispatcher));
	new serverName[128];
	get_user_name(0, serverName, charsmax(serverName));
	new serverIP[128];
	get_pcvar_string(pcvar_serverip, serverIP, charsmax(serverIP));
	if(equal(serverIP, "0"))
	{
		
		get_user_ip(0, serverIP, charsmax(serverIP));
	}
	get_user_authid(id, disAuth, charsmax(disAuth))
	get_user_authid(player, susAuth, charsmax(susAuth))
	
	new map[32];
	get_mapname(map, charsmax(map));
	
	new freindcode[64], communityID[128], serverInfo[128];
	
	msgid = Discord_StartMessage();
	if (msgid)
	{
		// Send Message to Discord Here;
		new empty[] = "_ _";
		
		// settings info ( avtar, username, footer and Color Of Embed)
		Discord_SetStringParam(USERNAME, "Calladmin Report System");
		
		//Discord_SetStringParam(FOOTER_TEXT, "CallAdmin Version %s [ Author: %s ]", VERSION, AUTHOR);
		Discord_SetCellParam(COLOR, 0x73e405);
		
		new serveradmin[64];
		
		get_pcvar_string(pcvar_serveradminid, serveradmin, charsmax(serveradmin));
		// content part ( mention admin here and ur message)
		if(!equal(serveradmin, "0"))
		{
			Discord_SetStringParam(CONTENT, "<@&%s> A new report has been made.", serveradmin);
		}
		else
		{
			Discord_SetStringParam(CONTENT, "A new report has been made.");
		}
		
		
		
		//Embed Part start from here
		
		// row 1, server name and ip
		formatex(serverInfo, charsmax(serverInfo), "[%s](http://ugc.gs/steam.php?addr=%s)", serverName, serverIP);
		
		
		
		Discord_AddField("Server Name",serverInfo, true);
		formatex(serverInfo, charsmax(serverInfo), "%s", serverIP);
		Discord_AddField("Server IP",serverInfo, true);
		Discord_AddField(empty, empty, true);
		
		// row 1, steam connect and map
		formatex(serverInfo, charsmax(serverInfo), "steam://connect/%s", serverIP);
		Discord_AddField("Steam Connect",serverInfo, true);
		Discord_AddField("Map",map, true);
		Discord_AddField(empty, empty, true);

		
		// row 3 , dispatcher name and authid
		Discord_AddField("Dispatcher Name",dispatcher, true);

		GetFriendID(disAuth,freindcode,charsmax(freindcode))
		formatex(communityID, charsmax(communityID), "[%s](http://steamcommunity.com/profiles/%s)", disAuth, freindcode);
		Discord_AddField("Dispatcher SteamID",communityID, true);
		Discord_AddField(empty, empty, true);
		
		
		
		// row 4 , suspect name and authid
		Discord_AddField("Suspect Name",suspect, true);
		GetFriendID(susAuth,freindcode,charsmax(freindcode))
		formatex(communityID, charsmax(communityID), "[%s](http://steamcommunity.com/profiles/%s)", susAuth, freindcode);
		Discord_AddField("Suspect SteamID",communityID, true);
		Discord_AddField(empty, empty, true);
		
		
		// row 5, Reason and Date & Time of report
		Discord_AddField("Reason",Reason, true);
		Discord_AddField("Date & Time",ctime, true);
		Discord_AddField(empty, empty, true);
		new url[128];
		formatex(url, charsmax(url), "http://ugc.gs/steam.php?addr=%s", serverIP);
		Discord_AddLinkButton("Connect", url);
		
		
		// lets store the report in array for making admin reply support
		static callreport[ calladmin_reports ];
		
		format(callreport[DISPATCHER_AUTHID], charsmax(callreport[DISPATCHER_AUTHID]), disAuth);
		format(callreport[DISPATCHER_NAME], charsmax(callreport[DISPATCHER_NAME]), dispatcher);
		format(callreport[SUSPECT_AUTHID], charsmax(callreport[SUSPECT_AUTHID]), susAuth);
		format(callreport[SUSPECT_NAME], charsmax(callreport[SUSPECT_NAME]), suspect);
		format(callreport[REASONS], charsmax(callreport[REASONS]), Reason);
		format(callreport[DATETIME], charsmax(callreport[DATETIME]), ctime);
		
		callreport[MESSAGEINDEX] = msgid;
		
		ArrayPushArray(reports, callreport);
		
		set_task(30.0, "check_report_spam", TASK_MSG_CHECK+msgid);
		
		Discord_SendMessage(webhook);
	}
	
	set_cooldown(id);
}

public check_report_spam(msgid)
{
	msgid -= TASK_MSG_CHECK;
	new szText[ 555 char ];
	for (new i = 0; i < ArraySize(reports); i++) 
	{
		static callreport[calladmin_reports];
		ArrayGetArray(reports, i, callreport);
		
		
		if(callreport[MESSAGEINDEX] == msgid)
		{
			if(equal(callreport[MESSAGEID], ""))
			{
				new user = find_player("c", callreport[DISPATCHER_AUTHID]);
				
				if(user && is_user_connected(user))
				{
					formatex( szText, charsmax( szText ), "%L %L", user, "CALLADMIN_PREFIX", user, "CALLADMIN_FAILED_TO_SEND" );
					client_print_color(user, print_team_default, szText);
					//client_print_color(user, user, "^1[^4Call Admin^1] ^3Failed to send ^4Call Admin Report.");
					clear_cooldown(user);
					
				}
				ArrayDeleteItem(reports, i);
			}
			
		}
	}
}

public Discord_MessageSent_Post(msgindex, const messageID[], const data[])
{
	new szText[ 555 char ];
	if(msgindex == msgid)
	{
		//client_print(0, print_chat, "Message Sent: %s", messageID);
		for (new i = 0; i < ArraySize(reports); i++) 
		{
			static callreport[calladmin_reports];
			ArrayGetArray(reports, i, callreport);
			
			
			if(callreport[MESSAGEINDEX] == msgindex)
			{
				format(callreport[MESSAGEID], charsmax(callreport[MESSAGEID]), messageID);
				ArrayDeleteItem(reports, i);
				ArrayPushArray(reports, callreport);
				
				inform_admins();
				
				new id = find_player("c", callreport[DISPATCHER_AUTHID])
				if(id && is_user_connected(id))
				{
					formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORT_SENT" );
					client_print_color(id, print_team_default, szText);
					//client_print_color(id, print_team_default, "^1[^4Call Admin^1] Your report has been submitted successfully.");
					return PLUGIN_HANDLED;
				}
			}
		}
	}
	return PLUGIN_CONTINUE;
}

public inform_admins()
{
	static iPlayers[32], iNum, id, i;
	new szText[ 555 char ];
	get_players( iPlayers, iNum ); 
	for( i = 0; i < iNum; i++ )
	{
		id = iPlayers[i];
		
		if(get_user_flags(id) & FLAG_CALL_ADMIN)
		{
			formatex( szText, charsmax( szText ), "%L %L", id, "CALLADMIN_PREFIX", id, "CALLADMIN_REPORT_MADED" );
			client_print_color(id, print_team_default, szText);
			//client_print_color(id, id, "^1[^4Call Admin^1] A new ^4Call Admin Report^1 has been made in this server. Check ^3/reprots^1.");
		}
	}
}


public set_cooldown(id)
{
	
	new authid[32];
	get_user_authid(id, authid, charsmax(authid));
	
	// clear if data exists
	for (new i = 0; i < ArraySize(g_aCallData); i++) 
	{
		static callAdminData[ CallData ];
		ArrayGetArray(g_aCallData, i, callAdminData);
		
		if(equal(callAdminData[AUTHID], authid))
		{
			ArrayDeleteItem(g_aCallData, i);
			
		}
		
	}
	// add data entry in array
	static callAdminDatas[ CallData ];
	new start_time = get_systime();
	
	format(callAdminDatas[AUTHID], charsmax(callAdminDatas[AUTHID]), authid);
	callAdminDatas[TIME_DISPATCHED] = start_time;
	
	ArrayPushArray(g_aCallData, callAdminDatas);
	
}

stock get_reason(id, reasonindex, reason[], len)
{
	
	if(reasonindex == 99)
	{
		if(format(reason, len, g_iReason[id]))
			return true;
	}
	else
	{
		
		static reasons[resonsInfo];
		ArrayGetArray(customReasons, reasonindex, reasons);
			
		if(format(reason, len, reasons[REASON]))
			return true;
	}
	
	return false;
	
}


stock str_explode(const string[], delimiter, output[][], output_size, output_len)
{
	new i, pos, len = strlen(string)
	do
	{
		pos += (copyc(output[i++], output_len, string[pos], delimiter) + 1)
	}
	while(pos < len && i < (output_size-1))
	pos += (copy(output[i++], output_len, string[pos]) + 1)
	
	return i
}

stock GetFriendID(const szAuthID[],szReturn[],iRetLen)
{
	static const szFriendsBaseNum[] = "76561197960265728"
	new szServer[2], szSteamID[64]
	
	new iServerPos = containi(szAuthID,":")
	if(iServerPos < 0)
		return 0
	
	strtok(szAuthID[iServerPos+1],szServer,charsmax(szServer),szSteamID,charsmax(szSteamID),':',1)
	
	//if(!is_str_num(szServer) || !is_str_num(szSteamID))
	//	return 0
	
	// AuthID * 2
	NumString_Add(szSteamID,szSteamID,szSteamID,charsmax(szSteamID))

	// AuthID + Base Number + Server Number
	NumString_Add(szSteamID,szFriendsBaseNum,szSteamID,charsmax(szSteamID))
	NumString_Add(szSteamID,szServer,szSteamID,charsmax(szSteamID))
	
	return (copy(szReturn,iRetLen,szSteamID) > 0)
}
	
stock NumString_Add(const szString1[],const szString2[],szReturn[], iRetLen)
{	
	new iLen1 = strlen(szString1), iLen2=strlen(szString2)
	if(!iLen1 || !iLen2)
		return
	
	static szTemp1[MAX_STR_NUM_LEN]
	copy(szTemp1,iLen1,szString1)
	
	static szTemp2[MAX_STR_NUM_LEN]
	copy(szTemp2,iLen2,szString2)
	
	static szTemp3[MAX_STR_NUM_LEN]
	
	new iTempNum,iCarry
	new iCharPos=0

	do
	{
		iTempNum = 0
		
		if(--iLen1 >= 0 && isdigit(szTemp1[iLen1]))
			iTempNum += char_to_num(szTemp1[iLen1])
		if(--iLen2 >= 0 && isdigit(szTemp2[iLen2]))
			iTempNum += char_to_num(szTemp2[iLen2])
		
		iTempNum += iCarry
		iTempNum -= ((iCarry = iTempNum / 10) * 10)
		
		szTemp3[iCharPos++] = num_to_char(iTempNum)
	}
	while(iLen1 >= 0 || iLen2 >= 0)
	
	new bool:iNumStarted = false
	new iLastChar = min(iRetLen, iCharPos),i
	
	if(iLastChar)
	{
		while(--iCharPos >= 0 && i < iLastChar)
		{
			if(szTemp3[iCharPos] == '0' && !iNumStarted)
				continue
			else
			{
				iNumStarted = true
				szReturn[i++] = szTemp3[iCharPos]
			}
		}
	}
}

stock char_to_num(chNum)
{
	new iNum
	switch(chNum)
	{
		case '0':		iNum = 0
		case '1':		iNum = 1
		case '2':		iNum = 2
		case '3':		iNum = 3
		case '4':		iNum = 4
		case '5':		iNum = 5
		case '6':		iNum = 6
		case '7':		iNum = 7
		case '8':		iNum = 8
		case '9':		iNum = 9
	}
	
	return iNum
}

stock num_to_char(iNum)
{
	new chNum
	switch(iNum)
	{
		case 0:		chNum = '0'
		case 1:		chNum = '1'
		case 2:		chNum = '2'
		case 3:		chNum = '3'
		case 4:		chNum = '4'
		case 5:		chNum = '5'
		case 6:		chNum = '6'
		case 7:		chNum = '7'
		case 8:		chNum = '8'
		case 9:		chNum = '9'
	}
	
	return chNum
}

FormatTime(time, buffer[], maxlen)
{
    new days, hours, minutes, seconds, len;

    //days = time / (60 * 60 * 24);
  //  hours = (time - (days * (60 * 60 * 24))) / (60 * 60);
    minutes = (time - (days * (60 * 60 * 24)) - (hours * (60 * 60))) / 60;
    seconds = time % 60;

    buffer[0] = 0;

   // if (days)
    //    len += formatex(buffer[len], maxlen - len, "%d %s", days, "days");

    //if (hours) 
   //     len += formatex(buffer[len], maxlen - len, "%s%d %s", days ? " " : "", hours, "hours");

    if (minutes)
        len += formatex(buffer[len], maxlen - len, "%s%d %s", (days || hours) ? " " : "", minutes, "minutes");

    if (seconds)
        formatex(buffer[len], maxlen - len, "%s%d %s", (days || hours || minutes) ? " " : "", seconds, "seconds");
}
